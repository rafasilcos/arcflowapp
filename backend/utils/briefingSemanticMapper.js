/**
 * üß† MAPEADOR SEM√ÇNTICO DE BRIEFINGS
 * 
 * Sistema din√¢mico para identificar campos por conte√∫do sem√¢ntico
 * em vez de posi√ß√µes fixas, permitindo briefings personalizados
 */

class BriefingSemanticMapper {
  constructor() {
    // Mapeamento sem√¢ntico por categorias e padr√µes
    this.camposSem√¢nticos = {
      // √ÅREA CONSTRU√çDA
      area_construida: {
        slugs: ['area_construida', 'areaConstruida', 'area_total', 'areaTotal'],
        palavrasChave: [
          '√°rea constru√≠da', 'area construida', '√°rea total', 'area total',
          'metragem', 'tamanho', 'dimens√£o', '√°rea do projeto', '√°rea edificada',
          '√°rea √∫til', '√°rea bruta', 'm¬≤', 'm2', 'metros quadrados'
        ],
        padroes: [
          /√°rea\s*(constru√≠da|total|do\s*projeto)/i,
          /metragem\s*(total|constru√≠da)/i,
          /tamanho\s*(do\s*projeto|da\s*constru√ß√£o)/i,
          /\d+\s*m[¬≤2]/i
        ],
        tipo: 'numero',
        unidade: 'm¬≤',
        validacao: (valor) => {
          const num = this.extrairNumero(valor);
          return num >= 20 && num <= 5000; // Faixa realista
        }
      },

      // √ÅREA DO TERRENO
      area_terreno: {
        slugs: ['area_terreno', 'areaTerreno', 'area_lote', 'areaLote'],
        perguntasEspecificas: ['62', '63'], // Perguntas espec√≠ficas conhecidas
        palavrasChave: [
          '√°rea do terreno', 'area do terreno', '√°rea terreno', 'area terreno',
          'tamanho do terreno', 'dimens√£o do terreno', '√°rea do lote', 'area do lote',
          'metragem do terreno', 'terreno', 'lote'
        ],
        padroes: [
          /√°rea\s*(do\s*)?terreno/i,
          /tamanho\s*(do\s*)?terreno/i,
          /dimens√£o\s*(do\s*)?terreno/i,
          /√°rea\s*(do\s*)?lote/i,
          /\d+\s*x\s*\d+/i // Dimens√µes como "15x30"
        ],
        tipo: 'numero',
        unidade: 'm¬≤',
        validacao: (valor) => {
          const num = this.extrairNumero(valor);
          return num >= 100 && num <= 10000; // Faixa realista para terrenos
        }
      },

      // LOCALIZA√á√ÉO
      localizacao: {
        slugs: ['localizacao', 'localiza√ß√£o', 'endereco', 'endere√ßo', 'cidade', 'local'],
        palavrasChave: [
          'localiza√ß√£o', 'localizacao', 'endere√ßo', 'endereco', 'cidade',
          'local', 'regi√£o', 'regiao', 'bairro', 'estado', 'munic√≠pio',
          'onde', 'aonde', 'lugar'
        ],
        padroes: [
          /localiza√ß√£o|localizacao/i,
          /endere√ßo|endereco/i,
          /cidade|munic√≠pio/i,
          /rua\s+[\w\s]+\d+/i, // Padr√£o de endere√ßo
          /\w+\s*\/\s*(sc|sp|rj|mg|pr|rs|ba|pe|ce|go|df)/i // Cidade/Estado
        ],
        tipo: 'texto',
        validacao: (valor) => {
          return typeof valor === 'string' && valor.length > 3;
        }
      },

      // TIPOLOGIA
      tipologia: {
        slugs: ['tipologia', 'tipo', 'categoria', 'tipo_projeto'],
        palavrasChave: [
          'tipologia', 'tipo', 'categoria', 'tipo de projeto', 'tipo projeto',
          'casa', 'apartamento', 'comercial', 'residencial', 'industrial'
        ],
        padroes: [
          /tipo\s*(de\s*)?projeto/i,
          /tipologia/i,
          /categoria/i,
          /(casa|apartamento|comercial|residencial|industrial)/i
        ],
        tipo: 'categoria',
        opcoes: ['residencial', 'comercial', 'industrial', 'institucional', 'unifamiliar', 'multifamiliar'],
        validacao: (valor) => {
          return typeof valor === 'string' && valor.length > 2;
        }
      },

      // √ÅREA DE ATUA√á√ÉO
      area_atuacao: {
        slugs: ['area_atuacao', 'areaAtuacao', 'segmento', 'setor'],
        palavrasChave: [
          '√°rea de atua√ß√£o', 'area de atuacao', 'segmento', 'setor',
          'tipo de obra', 'categoria do projeto', 'natureza do projeto'
        ],
        padroes: [
          /√°rea\s*de\s*atua√ß√£o/i,
          /segmento/i,
          /setor/i,
          /tipo\s*de\s*obra/i
        ],
        tipo: 'categoria',
        opcoes: ['residencial', 'comercial', 'industrial', 'institucional', 'mista'],
        validacao: (valor) => {
          const opcoes = ['residencial', 'comercial', 'industrial', 'institucional', 'mista'];
          return opcoes.some(opcao => valor.toLowerCase().includes(opcao));
        }
      },

      // PADR√ÉO/QUALIDADE
      padrao: {
        slugs: ['padrao', 'padr√£o', 'qualidade', 'nivel', 'n√≠vel'],
        palavrasChave: [
          'padr√£o', 'padrao', 'qualidade', 'n√≠vel', 'nivel',
          'alto padr√£o', 'm√©dio padr√£o', 'padr√£o simples',
          'luxo', 'premium', 'b√°sico', 'simples', 'econ√¥mico'
        ],
        padroes: [
          /(alto|m√©dio|baixo|simples)\s*padr√£o/i,
          /(luxo|premium|b√°sico|simples|econ√¥mico)/i,
          /qualidade\s*(alta|m√©dia|baixa)/i
        ],
        tipo: 'categoria',
        opcoes: ['simples', 'medio', 'alto'],
        validacao: (valor) => {
          const padroes = ['simples', 'medio', 'alto', 'b√°sico', 'luxo', 'premium'];
          return padroes.some(padrao => valor.toLowerCase().includes(padrao));
        }
      },

      // OR√áAMENTO/VALOR
      orcamento: {
        slugs: ['orcamento', 'or√ßamento', 'valor', 'preco', 'pre√ßo', 'investimento'],
        palavrasChave: [
          'or√ßamento', 'orcamento', 'valor', 'pre√ßo', 'preco',
          'investimento', 'custo', 'verba', 'budget'
        ],
        padroes: [
          /or√ßamento|orcamento/i,
          /valor|pre√ßo|preco/i,
          /investimento|custo/i,
          /r\$\s*[\d.,]+/i // Padr√£o monet√°rio brasileiro
        ],
        tipo: 'monetario',
        validacao: (valor) => {
          const num = this.extrairValorMonetario(valor);
          return num > 0;
        }
      },

      // PRAZO
      prazo: {
        slugs: ['prazo', 'tempo', 'duracao', 'dura√ß√£o', 'cronograma'],
        palavrasChave: [
          'prazo', 'tempo', 'dura√ß√£o', 'duracao', 'cronograma',
          'meses', 'dias', 'semanas', 'quando', 'entrega'
        ],
        padroes: [
          /prazo/i,
          /tempo\s*(de\s*)?(execu√ß√£o|entrega)/i,
          /dura√ß√£o|duracao/i,
          /\d+\s*(meses|dias|semanas)/i
        ],
        tipo: 'tempo',
        validacao: (valor) => {
          return /\d+/.test(valor);
        }
      }
    };

    // Padr√µes para identifica√ß√£o de caracter√≠sticas especiais
    this.caracteristicasEspeciais = {
      piscina: ['piscina', 'pool'],
      churrasqueira: ['churrasqueira', 'churras', 'grill', 'barbecue'],
      automacao: ['automa√ß√£o', 'automacao', 'dom√≥tica', 'domotica', 'smart home'],
      home_theater: ['home theater', 'cinema', 'sala de cinema'],
      jardim: ['jardim', 'paisagismo', '√°rea verde', 'verde'],
      garagem: ['garagem', 'estacionamento', 'vaga', 'vagas'],
      elevador: ['elevador', 'lift'],
      ar_condicionado: ['ar condicionado', 'climatiza√ß√£o', 'climatizacao'],
      aquecimento: ['aquecimento', 'aquecedor', 'heating'],
      seguranca: ['seguran√ßa', 'seguranca', 'alarme', 'c√¢meras', 'cameras']
    };
  }

  /**
   * üéØ M√©todo principal para mapear campos dinamicamente
   */
  mapearCampos(respostas) {
    console.log('üß† [SEMANTIC] Iniciando mapeamento sem√¢ntico de', Object.keys(respostas).length, 'respostas');
    
    const camposMapeados = {};
    const confiancaMapeamento = {};

    // Para cada campo sem√¢ntico que queremos encontrar
    for (const [nomeCampo, configuracao] of Object.entries(this.camposSem√¢nticos)) {
      const resultado = this.identificarCampo(nomeCampo, configuracao, respostas);
      
      if (resultado.encontrado) {
        camposMapeados[nomeCampo] = resultado.valor;
        confiancaMapeamento[nomeCampo] = resultado.confianca;
        
        console.log(`‚úÖ [SEMANTIC] ${nomeCampo} encontrado:`, {
          valor: resultado.valor,
          fonte: resultado.fonte,
          confianca: resultado.confianca + '%'
        });
      } else {
        console.log(`‚ö†Ô∏è [SEMANTIC] ${nomeCampo} n√£o encontrado`);
      }
    }

    // Identificar caracter√≠sticas especiais
    camposMapeados.caracteristicas_especiais = this.identificarCaracteristicas(respostas);

    return {
      campos: camposMapeados,
      confianca: confiancaMapeamento,
      totalCamposEncontrados: Object.keys(camposMapeados).length,
      totalCamposDisponiveis: Object.keys(this.camposSem√¢nticos).length
    };
  }

  /**
   * üîç Identificar um campo espec√≠fico nas respostas
   */
  identificarCampo(nomeCampo, configuracao, respostas) {
    let melhorMatch = null;
    let maiorConfianca = 0;

    // 1. Buscar por slugs diretos (maior confian√ßa)
    for (const slug of configuracao.slugs) {
      if (respostas[slug]) {
        const valor = this.processarValor(respostas[slug], configuracao);
        if (valor && configuracao.validacao(valor)) {
          return {
            encontrado: true,
            valor: valor,
            fonte: `slug_direto:${slug}`,
            confianca: 95
          };
        }
      }
    }

    // 2. Buscar por padr√µes regex (alta confian√ßa)
    for (const [chave, resposta] of Object.entries(respostas)) {
      if (typeof resposta !== 'string') continue;

      for (const padrao of configuracao.padroes) {
        if (padrao.test(resposta) || padrao.test(chave)) {
          const valor = this.processarValor(resposta, configuracao);
          if (valor && configuracao.validacao(valor)) {
            const confianca = this.calcularConfiancaContextual(nomeCampo, chave, resposta, 85);
            if (confianca > maiorConfianca) {
              melhorMatch = {
                encontrado: true,
                valor: valor,
                fonte: `padrao_regex:${chave}`,
                confianca: confianca
              };
              maiorConfianca = confianca;
            }
          }
        }
      }
    }

    // 3. Buscar por palavras-chave (m√©dia confian√ßa)
    for (const [chave, resposta] of Object.entries(respostas)) {
      if (typeof resposta !== 'string') continue;

      const chaveNormalizada = chave.toLowerCase();
      const respostaNormalizada = resposta.toLowerCase();

      for (const palavraChave of configuracao.palavrasChave) {
        if (chaveNormalizada.includes(palavraChave.toLowerCase()) || 
            respostaNormalizada.includes(palavraChave.toLowerCase())) {
          
          const valor = this.processarValor(resposta, configuracao);
          if (valor && configuracao.validacao(valor)) {
            const confianca = this.calcularConfiancaContextual(nomeCampo, chave, resposta, 70);
            if (confianca > maiorConfianca) {
              melhorMatch = {
                encontrado: true,
                valor: valor,
                fonte: `palavra_chave:${chave}`,
                confianca: confianca
              };
              maiorConfianca = confianca;
            }
          }
        }
      }
    }

    // 4. Busca heur√≠stica inteligente por tipo (baixa confian√ßa)
    if (!melhorMatch && configuracao.tipo === 'numero') {
      const numerosEncontrados = this.buscarNumerosPorTipoInteligente(respostas, configuracao, nomeCampo);
      if (numerosEncontrados.length > 0) {
        const melhorNumero = numerosEncontrados[0]; // J√° ordenado por relev√¢ncia
        melhorMatch = {
          encontrado: true,
          valor: melhorNumero.valor,
          fonte: `heuristica_inteligente:${melhorNumero.chave}`,
          confianca: melhorNumero.confianca
        };
      }
    }

    return melhorMatch || { encontrado: false };
  }

  /**
   * üß† Busca inteligente de n√∫meros por tipo espec√≠fico
   */
  buscarNumerosPorTipoInteligente(respostas, configuracao, nomeCampo) {
    const numerosEncontrados = [];
    const chavesJaUsadas = this.chavesJaUsadas || new Set();

    for (const [chave, resposta] of Object.entries(respostas)) {
      if (typeof resposta !== 'string') continue;
      
      // Evitar reutilizar a mesma chave para campos diferentes
      if (chavesJaUsadas.has(chave)) continue;

      const numero = this.extrairNumero(resposta);
      if (numero > 0 && configuracao.validacao(resposta)) {
        const relevanciaContextual = this.calcularRelevanciaContextual(numero, chave, resposta, nomeCampo, configuracao);
        
        numerosEncontrados.push({
          chave: chave,
          valor: numero,
          resposta: resposta,
          relevancia: relevanciaContextual.relevancia,
          confianca: relevanciaContextual.confianca,
          motivo: relevanciaContextual.motivo
        });
      }
    }

    // Ordenar por relev√¢ncia contextual
    const numerosOrdenados = numerosEncontrados.sort((a, b) => b.relevancia - a.relevancia);
    
    // Marcar a melhor chave como usada
    if (numerosOrdenados.length > 0) {
      if (!this.chavesJaUsadas) this.chavesJaUsadas = new Set();
      this.chavesJaUsadas.add(numerosOrdenados[0].chave);
    }

    return numerosOrdenados;
  }

  /**
   * üéØ Calcular relev√¢ncia contextual para um n√∫mero espec√≠fico
   */
  calcularRelevanciaContextual(numero, chave, resposta, nomeCampo, configuracao) {
    let relevancia = 0;
    let confianca = 30;
    let motivo = [];

    const chaveNormalizada = chave.toLowerCase();
    const respostaNormalizada = resposta.toLowerCase();

    // L√≥gica espec√≠fica para √°rea do terreno
    if (nomeCampo === 'area_terreno') {
      // Priorizar dimens√µes (ex: "20x25")
      if (/\d+\s*x\s*\d+/i.test(resposta)) {
        relevancia += 50;
        confianca += 30;
        motivo.push('dimensoes_terreno');
      }

      // Priorizar contexto de terreno
      if (chaveNormalizada.includes('terreno') || chaveNormalizada.includes('lote')) {
        relevancia += 40;
        confianca += 25;
        motivo.push('contexto_terreno');
      }

      // Penalizar se parece √°rea constru√≠da
      if (chaveNormalizada.includes('construi') || chaveNormalizada.includes('edifica')) {
        relevancia -= 30;
        confianca -= 20;
        motivo.push('penalizado_construida');
      }

      // Faixa de valores t√≠picos para terrenos (100-10000m¬≤)
      if (numero >= 200 && numero <= 2000) {
        relevancia += 20;
        confianca += 10;
        motivo.push('faixa_terreno_tipica');
      }
    }

    // L√≥gica espec√≠fica para √°rea constru√≠da
    if (nomeCampo === 'area_construida') {
      // Priorizar contexto de constru√ß√£o
      if (chaveNormalizada.includes('construi') || chaveNormalizada.includes('edifica') || 
          chaveNormalizada.includes('area') && !chaveNormalizada.includes('terreno')) {
        relevancia += 40;
        confianca += 25;
        motivo.push('contexto_construida');
      }

      // Penalizar se parece terreno
      if (chaveNormalizada.includes('terreno') || chaveNormalizada.includes('lote')) {
        relevancia -= 30;
        confianca -= 20;
        motivo.push('penalizado_terreno');
      }

      // Penalizar dimens√µes (mais prov√°vel ser terreno)
      if (/\d+\s*x\s*\d+/i.test(resposta)) {
        relevancia -= 20;
        confianca -= 15;
        motivo.push('penalizado_dimensoes');
      }

      // Faixa de valores t√≠picos para √°rea constru√≠da (50-1000m¬≤)
      if (numero >= 50 && numero <= 800) {
        relevancia += 20;
        confianca += 10;
        motivo.push('faixa_construida_tipica');
      }
    }

    // Relev√¢ncia base por valida√ß√£o
    if (configuracao.validacao(resposta)) {
      relevancia += this.calcularRelevanciaNumero(numero, configuracao);
      confianca += 10;
      motivo.push('validacao_passou');
    }

    return {
      relevancia: Math.max(0, relevancia),
      confianca: Math.min(90, Math.max(10, confianca)),
      motivo: motivo.join(', ')
    };
  }

  /**
   * üéØ Calcular confian√ßa contextual
   */
  calcularConfiancaContextual(nomeCampo, chave, resposta, confiancaBase) {
    let ajuste = 0;
    const chaveNormalizada = chave.toLowerCase();
    const respostaNormalizada = resposta.toLowerCase();

    // Ajustes espec√≠ficos por campo
    if (nomeCampo === 'area_terreno') {
      if (chaveNormalizada.includes('terreno') || chaveNormalizada.includes('lote')) {
        ajuste += 10;
      }
      if (/\d+\s*x\s*\d+/i.test(resposta)) {
        ajuste += 15; // Dimens√µes s√£o muito indicativas de terreno
      }
      if (chaveNormalizada.includes('construi')) {
        ajuste -= 20; // Penalizar se parece √°rea constru√≠da
      }
    }

    if (nomeCampo === 'area_construida') {
      if (chaveNormalizada.includes('construi') || chaveNormalizada.includes('edifica')) {
        ajuste += 10;
      }
      if (chaveNormalizada.includes('terreno')) {
        ajuste -= 20; // Penalizar se parece terreno
      }
      if (/\d+\s*x\s*\d+/i.test(resposta)) {
        ajuste -= 10; // Dimens√µes s√£o menos prov√°veis para √°rea constru√≠da
      }
    }

    return Math.min(95, Math.max(10, confiancaBase + ajuste));
  }

  /**
   * üìä Calcular relev√¢ncia de um n√∫mero para um tipo espec√≠fico
   */
  calcularRelevanciaNumero(numero, configuracao) {
    // L√≥gica espec√≠fica por tipo de campo
    if (configuracao.unidade === 'm¬≤') {
      // Para √°reas, n√∫meros entre 50-500 s√£o mais relevantes
      if (numero >= 50 && numero <= 500) return 100;
      if (numero >= 20 && numero <= 1000) return 80;
      if (numero >= 10 && numero <= 2000) return 60;
      return 20;
    }

    return 50; // Relev√¢ncia padr√£o
  }

  /**
   * ‚ú® Identificar caracter√≠sticas especiais
   */
  identificarCaracteristicas(respostas) {
    const caracteristicasEncontradas = [];
    const textoCompleto = JSON.stringify(respostas).toLowerCase();

    for (const [caracteristica, palavras] of Object.entries(this.caracteristicasEspeciais)) {
      for (const palavra of palavras) {
        if (textoCompleto.includes(palavra.toLowerCase())) {
          caracteristicasEncontradas.push(caracteristica);
          break;
        }
      }
    }

    console.log('‚ú® [SEMANTIC] Caracter√≠sticas especiais encontradas:', caracteristicasEncontradas);
    return caracteristicasEncontradas;
  }

  /**
   * üîÑ Processar valor de acordo com o tipo
   */
  processarValor(valor, configuracao) {
    switch (configuracao.tipo) {
      case 'numero':
        return this.extrairNumero(valor);
      case 'monetario':
        return this.extrairValorMonetario(valor);
      case 'tempo':
        return this.extrairTempo(valor);
      case 'categoria':
        return this.processarCategoria(valor, configuracao.opcoes);
      case 'texto':
      default:
        return typeof valor === 'string' ? valor.trim() : valor;
    }
  }

  /**
   * üî¢ Extrair n√∫mero de um texto
   */
  extrairNumero(texto) {
    if (typeof texto !== 'string') return 0;

    // Primeiro, tentar n√∫mero simples
    const numeroSimples = texto.trim();
    if (/^\d+$/.test(numeroSimples)) {
      return parseInt(numeroSimples);
    }

    // Calcular √°rea de dimens√µes (ex: "15x30")
    const dimensoes = texto.match(/(\d+)\s*x\s*(\d+)/i);
    if (dimensoes) {
      return parseInt(dimensoes[1]) * parseInt(dimensoes[2]);
    }

    // Extrair qualquer n√∫mero do texto
    const numeros = texto.match(/\d+(?:\.\d+)?/g);
    if (numeros) {
      return parseFloat(numeros[0]);
    }

    return 0;
  }

  /**
   * üí∞ Extrair valor monet√°rio
   */
  extrairValorMonetario(texto) {
    if (typeof texto !== 'string') return 0;

    // Remover formata√ß√£o monet√°ria brasileira
    const numeroLimpo = texto
      .replace(/r\$\s*/gi, '')
      .replace(/\./g, '')
      .replace(/,/g, '.');

    const numero = parseFloat(numeroLimpo);
    return isNaN(numero) ? 0 : numero;
  }

  /**
   * ‚è∞ Extrair tempo
   */
  extrairTempo(texto) {
    if (typeof texto !== 'string') return texto;

    // Extrair n√∫mero e unidade
    const match = texto.match(/(\d+)\s*(meses|dias|semanas|anos)/i);
    if (match) {
      const numero = parseInt(match[1]);
      const unidade = match[2].toLowerCase();
      
      // Converter tudo para dias
      switch (unidade) {
        case 'anos': return numero * 365;
        case 'meses': return numero * 30;
        case 'semanas': return numero * 7;
        case 'dias': return numero;
        default: return numero;
      }
    }

    return texto;
  }

  /**
   * üìÇ Processar categoria
   */
  processarCategoria(valor, opcoes) {
    if (typeof valor !== 'string') return valor;

    const valorLower = valor.toLowerCase();
    
    // Buscar correspond√™ncia exata ou parcial
    for (const opcao of opcoes) {
      if (valorLower.includes(opcao.toLowerCase()) || opcao.toLowerCase().includes(valorLower)) {
        return opcao;
      }
    }

    return valor;
  }
}

module.exports = BriefingSemanticMapper;