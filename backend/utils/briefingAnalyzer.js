/**
 * üß† ANALISADOR INTELIGENTE DE BRIEFINGS
 * 
 * Sistema avan√ßado para extrair dados precisos dos briefings
 * e alimentar a gera√ß√£o de or√ßamentos com informa√ß√µes corretas
 */

class BriefingAnalyzer {
  constructor() {
    // Padr√µes para identifica√ß√£o de tipologias
    this.tipologiaPatterns = {
      'RESIDENCIAL': [
        'residencial', 'casa', 'apartamento', 'resid√™ncia', 'moradia',
        'unifamiliar', 'multifamiliar', 'condom√≠nio', 'sobrado',
        'piscina', 'churrasqueira', 'home theater', 'su√≠te'
      ],
      'COMERCIAL': [
        'comercial', 'loja', 'escrit√≥rio', 'consult√≥rio', 'cl√≠nica',
        'restaurante', 'bar', 'hotel', 'pousada', 'sal√£o',
        'coworking', 'franquia', 'varejo', 'atendimento'
      ],
      'INDUSTRIAL': [
        'industrial', 'galp√£o', 'f√°brica', 'ind√∫stria', 'armaz√©m',
        'dep√≥sito', 'log√≠stica', 'produ√ß√£o', 'manufatura'
      ],
      'INSTITUCIONAL': [
        'escola', 'hospital', 'igreja', 'creche', 'universidade',
        'biblioteca', 'museu', 'teatro', 'audit√≥rio', 'p√∫blico'
      ]
    };

    // Padr√µes para identifica√ß√£o de complexidade/padr√£o
    this.padraoPatterns = {
      'ALTO': [
        'alto padr√£o', 'luxo', 'premium', 'sofisticado', 'requintado',
        'exclusivo', 'diferenciado', 'high-end', 'automa√ß√£o',
        'dom√≥tica', 'm√°rmore', 'granito', 'madeira nobre'
      ],
      'MEDIO': [
        'm√©dio padr√£o', 'padr√£o', 'intermedi√°rio', 'bom acabamento',
        'qualidade', 'confort√°vel', 'funcional'
      ],
      'SIMPLES': [
        'simples', 'b√°sico', 'econ√¥mico', 'popular', 'essencial',
        'm√≠nimo', 'funcional', 'sem luxo'
      ]
    };

    // Padr√µes para identifica√ß√£o de disciplinas
    this.disciplinaPatterns = {
      'ARQUITETURA': ['arquitet√¥nico', 'arquitetura', 'projeto arquitet√¥nico', 'layout', 'planta'],
      'ESTRUTURAL': ['estrutural', 'estrutura', 'funda√ß√£o', 'laje', 'viga', 'pilar'],
      'INSTALACOES_HIDRAULICAS': ['hidr√°ulica', '√°gua', 'esgoto', 'tubula√ß√£o', 'encanamento'],
      'INSTALACOES_ELETRICAS': ['el√©trica', 'energia', 'ilumina√ß√£o', 'tomadas', 'quadro el√©trico'],
      'CLIMATIZACAO': ['ar condicionado', 'climatiza√ß√£o', 'ventila√ß√£o', 'exaust√£o'],
      'PAISAGISMO': ['paisagismo', 'jardim', '√°rea verde', 'plantas', 'vegeta√ß√£o'],
      'INTERIORES': ['interiores', 'decora√ß√£o', 'mobili√°rio', 'design de interiores'],
      'APROVACAO_LEGAL': ['aprova√ß√£o', 'prefeitura', 'bombeiros', 'legal', 'licen√ßa'],
      'MODELAGEM_3D': ['3d', 'maquete', 'renderiza√ß√£o', 'visualiza√ß√£o']
    };
  }

  /**
   * üéØ M√©todo principal para extrair dados estruturados do briefing
   */
  async extrairDadosEstruturados(briefing) {
    console.log('üß† [ANALYZER] Iniciando an√°lise inteligente do briefing:', briefing.id);
    
    try {
      // 1. Extrair respostas do briefing
      const respostas = this.extrairRespostas(briefing);
      console.log('üìã [ANALYZER] Total de respostas encontradas:', Object.keys(respostas).length);
      
      // 2. Analisar dados b√°sicos do briefing
      const dadosBasicos = this.analisarDadosBasicos(briefing);
      
      // 3. Extrair informa√ß√µes espec√≠ficas das respostas
      const dadosExtraidos = {
        // Dados b√°sicos do briefing
        ...dadosBasicos,
        
        // An√°lise das respostas
        areaAtuacao: this.extrairAreaAtuacao(respostas, briefing),
        tipologia: this.identificarTipologia(respostas, briefing),
        areaConstruida: this.extrairAreaConstruida(respostas),
        areaTerreno: this.extrairAreaTerreno(respostas),
        padrao: this.identificarPadrao(respostas),
        complexidade: this.calcularComplexidade(respostas),
        disciplinasNecessarias: this.identificarDisciplinas(respostas, briefing),
        localizacao: this.extrairLocalizacao(respostas),
        caracteristicasEspeciais: this.extrairCaracteristicas(respostas),
        prazoEstimado: this.estimarPrazo(respostas),
        
        // Metadados da an√°lise
        confianca: this.calcularConfianca(respostas),
        fonteDados: 'briefing_estruturado',
        timestampAnalise: new Date().toISOString(),
        versaoAnalyzer: '2.0.0'
      };
      
      console.log('‚úÖ [ANALYZER] Dados extra√≠dos com sucesso:', {
        tipologia: dadosExtraidos.tipologia,
        areaConstruida: dadosExtraidos.areaConstruida,
        padrao: dadosExtraidos.padrao,
        disciplinas: dadosExtraidos.disciplinasNecessarias.length,
        confianca: dadosExtraidos.confianca
      });
      
      return dadosExtraidos;
      
    } catch (error) {
      console.error('‚ùå [ANALYZER] Erro na an√°lise:', error);
      throw new Error(`Erro na an√°lise do briefing: ${error.message}`);
    }
  }

  /**
   * üìã Extrair respostas do briefing
   */
  extrairRespostas(briefing) {
    let respostas = {};
    
    // Tentar extrair das observa√ß√µes
    if (briefing.observacoes) {
      try {
        const observacoes = JSON.parse(briefing.observacoes);
        if (observacoes.respostas) {
          respostas = { ...respostas, ...observacoes.respostas };
        }
        if (observacoes.estruturaPersonalizada?.respostas) {
          respostas = { ...respostas, ...observacoes.estruturaPersonalizada.respostas };
        }
      } catch (error) {
        console.warn('‚ö†Ô∏è [ANALYZER] Erro ao parsear observa√ß√µes:', error.message);
      }
    }
    
    // Tentar extrair dos dados_extraidos
    if (briefing.dados_extraidos) {
      try {
        const dadosExtraidos = JSON.parse(briefing.dados_extraidos);
        if (dadosExtraidos.respostas) {
          respostas = { ...respostas, ...dadosExtraidos.respostas };
        }
      } catch (error) {
        console.warn('‚ö†Ô∏è [ANALYZER] Erro ao parsear dados_extraidos:', error.message);
      }
    }
    
    // Tentar extrair da metadata
    if (briefing.metadata) {
      try {
        const metadata = JSON.parse(briefing.metadata);
        if (metadata.respostas) {
          respostas = { ...respostas, ...metadata.respostas };
        }
      } catch (error) {
        console.warn('‚ö†Ô∏è [ANALYZER] Erro ao parsear metadata:', error.message);
      }
    }
    
    return respostas;
  }

  /**
   * üìä Analisar dados b√°sicos do briefing
   */
  analisarDadosBasicos(briefing) {
    return {
      briefingId: briefing.id,
      nomeProjeto: briefing.nome_projeto,
      clienteId: briefing.cliente_id,
      clienteNome: briefing.cliente_nome,
      responsavelId: briefing.responsavel_id,
      responsavelNome: briefing.responsavel_nome,
      escritorioId: briefing.escritorio_id,
      disciplinaPrincipal: briefing.disciplina,
      tipologiaOriginal: briefing.tipologia,
      areaOriginal: briefing.area,
      descricao: briefing.descricao,
      objetivos: briefing.objetivos,
      prazoOriginal: briefing.prazo,
      orcamentoOriginal: briefing.orcamento
    };
  }

  /**
   * üè¢ Extrair √°rea de atua√ß√£o (RESIDENCIAL, COMERCIAL, etc.)
   */
  extrairAreaAtuacao(respostas, briefing) {
    console.log('üè¢ [ANALYZER] Iniciando extra√ß√£o de √°rea de atua√ß√£o...');
    
    // 1. Verificar campo 'area' do briefing (que pode conter √°rea de atua√ß√£o)
    if (briefing.area && typeof briefing.area === 'string') {
      const areaLower = briefing.area.toLowerCase();
      const tiposAtuacao = ['residencial', 'comercial', 'industrial', 'institucional', 'mista'];
      
      for (const tipo of tiposAtuacao) {
        if (areaLower.includes(tipo)) {
          console.log('üè¢ [ANALYZER] √Årea de atua√ß√£o encontrada no campo area do briefing:', tipo.toUpperCase());
          return tipo.toUpperCase();
        }
      }
    }
    
    // 2. Procurar por perguntas espec√≠ficas conhecidas (pergunta 66 para residencial)
    const perguntasAtuacaoConhecidas = ['66', '67', '1', '2']; // Perguntas comuns de √°rea de atua√ß√£o
    
    for (const pergunta of perguntasAtuacaoConhecidas) {
      if (respostas[pergunta]) {
        const valor = respostas[pergunta].toLowerCase();
        const tiposAtuacao = ['residencial', 'comercial', 'industrial', 'institucional', 'mista'];
        
        for (const tipo of tiposAtuacao) {
          if (valor.includes(tipo)) {
            console.log('üè¢ [ANALYZER] √Årea de atua√ß√£o encontrada na pergunta', pergunta, ':', tipo.toUpperCase());
            return tipo.toUpperCase();
          }
        }
      }
    }
    
    // 3. Procurar por palavras-chave relacionadas √† √°rea de atua√ß√£o
    const palavrasChaveAtuacao = ['atua√ß√£o', 'tipo', 'categoria', '√°rea de', 'segmento', 'setor'];
    
    for (const [key, value] of Object.entries(respostas)) {
      if (typeof value === 'string') {
        const keyLower = key.toLowerCase();
        const valueLower = value.toLowerCase();
        
        // Verificar se a pergunta cont√©m palavras relacionadas √† √°rea de atua√ß√£o
        if (palavrasChaveAtuacao.some(palavra => keyLower.includes(palavra))) {
          const tiposAtuacao = ['residencial', 'comercial', 'industrial', 'institucional', 'mista'];
          
          for (const tipo of tiposAtuacao) {
            if (valueLower.includes(tipo)) {
              console.log('üè¢ [ANALYZER] √Årea de atua√ß√£o encontrada por palavra-chave na pergunta', key, ':', tipo.toUpperCase());
              return tipo.toUpperCase();
            }
          }
        }
      }
    }
    
    // 4. Procurar em todas as respostas por tipos de atua√ß√£o
    for (const [key, value] of Object.entries(respostas)) {
      if (typeof value === 'string') {
        const valueLower = value.toLowerCase();
        const tiposAtuacao = ['residencial', 'comercial', 'industrial', 'institucional', 'mista'];
        
        for (const tipo of tiposAtuacao) {
          if (valueLower === tipo || valueLower.includes(tipo)) {
            console.log('üè¢ [ANALYZER] √Årea de atua√ß√£o encontrada na resposta', key, ':', tipo.toUpperCase());
            return tipo.toUpperCase();
          }
        }
      }
    }
    
    console.warn('‚ö†Ô∏è [ANALYZER] √Årea de atua√ß√£o n√£o encontrada, usando padr√£o baseado na tipologia');
    
    // 5. Fallback: inferir da tipologia se dispon√≠vel
    if (briefing.tipologia) {
      const tipologiaLower = briefing.tipologia.toLowerCase();
      if (tipologiaLower.includes('unifamiliar') || tipologiaLower.includes('casa') || tipologiaLower.includes('apartamento')) {
        console.log('üè¢ [ANALYZER] √Årea de atua√ß√£o inferida da tipologia: RESIDENCIAL');
        return 'RESIDENCIAL';
      }
    }
    
    return 'RESIDENCIAL'; // Padr√£o mais comum
  }

  /**
   * üè† Identificar tipologia do projeto
   */
  identificarTipologia(respostas, briefing) {
    // 1. Verificar tipologia j√° definida no briefing
    if (briefing.tipologia && briefing.tipologia !== 'null') {
      console.log('üè† [ANALYZER] Tipologia do briefing:', briefing.tipologia);
      return briefing.tipologia.toUpperCase();
    }
    
    // 2. Analisar respostas para identificar tipologia
    const textoCompleto = JSON.stringify(respostas).toLowerCase();
    let pontuacoes = {};
    
    Object.entries(this.tipologiaPatterns).forEach(([tipo, patterns]) => {
      pontuacoes[tipo] = 0;
      patterns.forEach(pattern => {
        const matches = (textoCompleto.match(new RegExp(pattern, 'gi')) || []).length;
        pontuacoes[tipo] += matches;
      });
    });
    
    // Encontrar tipologia com maior pontua√ß√£o
    const tipologiaIdentificada = Object.entries(pontuacoes)
      .sort(([,a], [,b]) => b - a)[0][0];
    
    console.log('üè† [ANALYZER] Pontua√ß√µes de tipologia:', pontuacoes);
    console.log('üè† [ANALYZER] Tipologia identificada:', tipologiaIdentificada);
    
    return tipologiaIdentificada;
  }

  /**
   * üìê Extrair √°rea constru√≠da
   */
  extrairAreaConstruida(respostas) {
    console.log('üìê [ANALYZER] Iniciando extra√ß√£o de √°rea constru√≠da...');
    
    // 1. Procurar por campos espec√≠ficos de √°rea (nomes diretos)
    const camposAreaDiretos = [
      'area_construida', 'areaConstruida', 'area_total', 'areaTotal',
      'area', 'metragem', 'tamanho', 'dimensao'
    ];
    
    for (const campo of camposAreaDiretos) {
      if (respostas[campo]) {
        const area = this.extrairNumeroArea(respostas[campo]);
        if (area > 0) {
          console.log('üìê [ANALYZER] √Årea encontrada no campo direto', campo, ':', area, 'm¬≤');
          return area;
        }
      }
    }
    
    // 2. Procurar por perguntas espec√≠ficas conhecidas (pergunta 24 para residencial)
    const perguntasAreaConhecidas = ['24', '25', '26']; // Perguntas comuns de √°rea
    
    for (const pergunta of perguntasAreaConhecidas) {
      if (respostas[pergunta]) {
        const area = this.extrairNumeroArea(respostas[pergunta]);
        if (area > 0) {
          console.log('üìê [ANALYZER] √Årea encontrada na pergunta', pergunta, ':', area, 'm¬≤');
          return area;
        }
      }
    }
    
    // 3. Procurar por palavras-chave relacionadas √† √°rea nas perguntas
    const palavrasChaveArea = ['√°rea', 'area', 'metragem', 'tamanho', 'dimens√£o', 'constru√≠da', 'total'];
    
    for (const [key, value] of Object.entries(respostas)) {
      if (typeof value === 'string') {
        const keyLower = key.toLowerCase();
        
        // Verificar se a pergunta cont√©m palavras relacionadas √† √°rea
        if (palavrasChaveArea.some(palavra => keyLower.includes(palavra))) {
          const area = this.extrairNumeroArea(value);
          if (area > 0) {
            console.log('üìê [ANALYZER] √Årea encontrada por palavra-chave na pergunta', key, ':', area, 'm¬≤');
            return area;
          }
        }
      }
    }
    
    // 4. Procurar por n√∫meros que podem representar √°rea (50-2000m¬≤)
    const areasEncontradas = [];
    
    for (const [key, value] of Object.entries(respostas)) {
      if (typeof value === 'string') {
        const area = this.extrairNumeroArea(value);
        if (area >= 50 && area <= 2000) { // Faixa realista para projetos
          areasEncontradas.push({
            pergunta: key,
            area: area,
            valor: value
          });
        }
      }
    }
    
    if (areasEncontradas.length > 0) {
      // Ordenar por √°rea (maior primeiro) e pegar a mais prov√°vel
      areasEncontradas.sort((a, b) => b.area - a.area);
      const areaSelecionada = areasEncontradas[0];
      
      console.log('üìê [ANALYZER] √Årea encontrada por an√°lise num√©rica na pergunta', areaSelecionada.pergunta, ':', areaSelecionada.area, 'm¬≤');
      console.log('üìê [ANALYZER] Outras √°reas encontradas:', areasEncontradas.slice(1).map(a => `${a.pergunta}:${a.area}m¬≤`).join(', '));
      
      return areaSelecionada.area;
    }
    
    console.warn('‚ö†Ô∏è [ANALYZER] √Årea n√£o encontrada, usando padr√£o: 150m¬≤');
    return 150; // Valor padr√£o
  }

  /**
   * üåç Extrair √°rea do terreno
   */
  extrairAreaTerreno(respostas) {
    console.log('üèûÔ∏è [ANALYZER] Iniciando extra√ß√£o de √°rea do terreno...');
    
    // 1. Mapeamento espec√≠fico de perguntas conhecidas para √°rea do terreno
    const perguntasAreaTerreno = ['62', '63']; // Pergunta 62: √°rea, 63: dimens√µes
    
    // Primeiro, verifica perguntas espec√≠ficas conhecidas
    for (const pergunta of perguntasAreaTerreno) {
      if (respostas[pergunta]) {
        const resposta = respostas[pergunta];
        console.log(`üèûÔ∏è [ANALYZER] Verificando pergunta ${pergunta}: "${resposta}"`);
        
        // Se for a pergunta 62, extrai n√∫mero direto (√°rea em m¬≤)
        if (pergunta === '62') {
          const numero = this.extrairNumeroArea(resposta);
          if (numero && numero > 50 && numero < 50000) {
            console.log(`üèûÔ∏è [ANALYZER] √Årea do terreno encontrada na pergunta ${pergunta}: ${numero} m¬≤`);
            return numero;
          }
        }
        
        // Se for a pergunta 63, calcula √°rea a partir das dimens√µes (ex: "15x30")
        if (pergunta === '63') {
          const dimensoes = resposta.match(/(\d+)\s*x\s*(\d+)/i);
          if (dimensoes) {
            const largura = parseInt(dimensoes[1]);
            const comprimento = parseInt(dimensoes[2]);
            const area = largura * comprimento;
            console.log(`üèûÔ∏è [ANALYZER] √Årea calculada das dimens√µes ${largura}x${comprimento}: ${area} m¬≤`);
            return area;
          }
        }
      }
    }
    
    // 2. Procurar por campos espec√≠ficos de terreno (nomes diretos)
    const camposTerrenoDiretos = [
      'area_terreno', 'areaTerreno', 'terreno', 'lote', 'area_lote', 'areaLote'
    ];
    
    for (const campo of camposTerrenoDiretos) {
      if (respostas[campo]) {
        const area = this.extrairNumeroArea(respostas[campo]);
        if (area > 0) {
          console.log('üèûÔ∏è [ANALYZER] √Årea do terreno encontrada no campo direto', campo, ':', area, 'm¬≤');
          return area;
        }
      }
    }
    
    // 3. Procurar por palavras-chave relacionadas ao terreno
    const palavrasChaveTerreno = ['terreno', 'lote', '√°rea do terreno', 'tamanho do terreno', 'dimens√£o do terreno'];
    
    for (const [key, value] of Object.entries(respostas)) {
      if (typeof value === 'string') {
        const keyLower = key.toLowerCase();
        const valueLower = value.toLowerCase();
        
        // Verificar se a pergunta cont√©m palavras relacionadas ao terreno
        if (palavrasChaveTerreno.some(palavra => keyLower.includes(palavra) || valueLower.includes(palavra))) {
          const area = this.extrairNumeroArea(value);
          if (area > 0) {
            console.log('üèûÔ∏è [ANALYZER] √Årea do terreno encontrada por palavra-chave na pergunta', key, ':', area, 'm¬≤');
            return area;
          }
        }
      }
    }
    
    // 4. Procurar por n√∫meros que podem representar √°rea de terreno (100-5000m¬≤)
    const areasEncontradas = [];
    
    for (const [key, value] of Object.entries(respostas)) {
      if (typeof value === 'string') {
        const area = this.extrairNumeroArea(value);
        if (area >= 100 && area <= 5000) { // Faixa realista para terrenos
          // Verificar se n√£o √© a √°rea constru√≠da (que j√° foi extra√≠da)
          const areaConstrutida = this.extrairAreaConstruida(respostas);
          if (area !== areaConstrutida) {
            areasEncontradas.push({
              pergunta: key,
              area: area,
              valor: value
            });
          }
        }
      }
    }
    
    if (areasEncontradas.length > 0) {
      // Ordenar por √°rea (maior primeiro) e pegar a mais prov√°vel para terreno
      areasEncontradas.sort((a, b) => b.area - a.area);
      const areaSelecionada = areasEncontradas[0];
      
      console.log('üèûÔ∏è [ANALYZER] √Årea do terreno encontrada por an√°lise num√©rica na pergunta', areaSelecionada.pergunta, ':', areaSelecionada.area, 'm¬≤');
      console.log('üèûÔ∏è [ANALYZER] Outras √°reas de terreno encontradas:', areasEncontradas.slice(1).map(a => `${a.pergunta}:${a.area}m¬≤`).join(', '));
      
      return areaSelecionada.area;
    }
    
    console.warn('‚ö†Ô∏è [ANALYZER] √Årea do terreno n√£o encontrada');
    return null;
  }

  /**
   * üî¢ Extrair n√∫mero da √°rea de um texto
   */
  extrairNumeroArea(texto) {
    if (typeof texto !== 'string') return 0;
    
    // Primeiro, tentar extrair n√∫mero simples (como "250")
    const numeroSimples = texto.trim();
    if (/^\d+$/.test(numeroSimples)) {
      const numero = parseInt(numeroSimples);
      if (numero >= 10 && numero <= 10000) {
        console.log('üî¢ [ANALYZER] N√∫mero simples encontrado:', numero);
        return numero;
      }
    }
    
    // Padr√µes para encontrar √°rea em m¬≤ ou com texto
    const patterns = [
      /(\d+(?:\.\d+)?)\s*m¬≤/gi,
      /(\d+(?:\.\d+)?)\s*metros?\s*quadrados?/gi,
      /(\d+(?:\.\d+)?)\s*m2/gi,
      /√°rea.*?(\d+(?:\.\d+)?)/gi,
      /(\d+(?:\.\d+)?)\s*metros/gi,
      /(\d+(?:\.\d+)?)/gi // Qualquer n√∫mero
    ];
    
    for (const pattern of patterns) {
      const matches = texto.match(pattern);
      if (matches) {
        for (const match of matches) {
          const numero = parseFloat(match.replace(/[^\d.]/g, ''));
          if (numero >= 10 && numero <= 10000) { // Valida√ß√£o b√°sica
            console.log('üî¢ [ANALYZER] N√∫mero extra√≠do do padr√£o:', numero, 'de:', match);
            return Math.round(numero);
          }
        }
      }
    }
    
    return 0;
  }

  /**
   * ‚≠ê Identificar padr√£o do projeto
   */
  identificarPadrao(respostas) {
    const textoCompleto = JSON.stringify(respostas).toLowerCase();
    let pontuacoes = {};
    
    Object.entries(this.padraoPatterns).forEach(([padrao, patterns]) => {
      pontuacoes[padrao] = 0;
      patterns.forEach(pattern => {
        const matches = (textoCompleto.match(new RegExp(pattern, 'gi')) || []).length;
        pontuacoes[padrao] += matches;
      });
    });
    
    // Encontrar padr√£o com maior pontua√ß√£o
    const padraoIdentificado = Object.entries(pontuacoes)
      .sort(([,a], [,b]) => b - a)[0][0];
    
    console.log('‚≠ê [ANALYZER] Pontua√ß√µes de padr√£o:', pontuacoes);
    console.log('‚≠ê [ANALYZER] Padr√£o identificado:', padraoIdentificado);
    
    return padraoIdentificado.toLowerCase();
  }

  /**
   * üéØ Calcular complexidade
   */
  calcularComplexidade(respostas) {
    const padrao = this.identificarPadrao(respostas);
    const totalRespostas = Object.keys(respostas).length;
    
    // Fatores de complexidade
    let pontuacaoComplexidade = 0;
    
    // Baseado no padr√£o
    if (padrao === 'alto') pontuacaoComplexidade += 3;
    else if (padrao === 'medio') pontuacaoComplexidade += 2;
    else pontuacaoComplexidade += 1;
    
    // Baseado no n√∫mero de respostas
    if (totalRespostas > 20) pontuacaoComplexidade += 2;
    else if (totalRespostas > 10) pontuacaoComplexidade += 1;
    
    // Baseado em caracter√≠sticas especiais
    const textoCompleto = JSON.stringify(respostas).toLowerCase();
    const caracteristicasComplexas = [
      'automa√ß√£o', 'dom√≥tica', 'piscina', 'elevador', 'ar condicionado',
      'aquecimento', 'sistema de seguran√ßa', 'home theater'
    ];
    
    caracteristicasComplexas.forEach(caracteristica => {
      if (textoCompleto.includes(caracteristica)) {
        pontuacaoComplexidade += 1;
      }
    });
    
    // Determinar complexidade final
    let complexidade;
    if (pontuacaoComplexidade >= 6) complexidade = 'alta';
    else if (pontuacaoComplexidade >= 3) complexidade = 'media';
    else complexidade = 'simples';
    
    console.log('üéØ [ANALYZER] Pontua√ß√£o de complexidade:', pontuacaoComplexidade);
    console.log('üéØ [ANALYZER] Complexidade calculada:', complexidade);
    
    return complexidade;
  }

  /**
   * üîß Identificar disciplinas necess√°rias
   */
  identificarDisciplinas(respostas, briefing) {
    const disciplinasIdentificadas = new Set();
    
    // Sempre incluir a disciplina principal do briefing
    if (briefing.disciplina) {
      disciplinasIdentificadas.add(briefing.disciplina.toLowerCase());
    }
    
    // Analisar respostas para identificar outras disciplinas
    const textoCompleto = JSON.stringify(respostas).toLowerCase();
    
    Object.entries(this.disciplinaPatterns).forEach(([disciplina, patterns]) => {
      patterns.forEach(pattern => {
        if (textoCompleto.includes(pattern)) {
          disciplinasIdentificadas.add(disciplina.toLowerCase());
        }
      });
    });
    
    // Disciplinas b√°sicas sempre necess√°rias
    const disciplinasBasicas = ['arquitetura', 'estrutural', 'instalacoes_hidraulicas', 'instalacoes_eletricas'];
    disciplinasBasicas.forEach(disc => disciplinasIdentificadas.add(disc));
    
    const resultado = Array.from(disciplinasIdentificadas);
    console.log('üîß [ANALYZER] Disciplinas identificadas:', resultado);
    
    return resultado;
  }

  /**
   * üìç Extrair localiza√ß√£o
   */
  extrairLocalizacao(respostas) {
    console.log('üìç [ANALYZER] Iniciando extra√ß√£o de localiza√ß√£o...');
    
    // 1. Mapeamento espec√≠fico de perguntas conhecidas para localiza√ß√£o
    const perguntasLocalizacaoConhecidas = ['61', '13']; // Pergunta 61: endere√ßo completo, 13: cidade/regi√£o
    
    // Primeiro, verifica perguntas espec√≠ficas conhecidas
    for (const pergunta of perguntasLocalizacaoConhecidas) {
      if (respostas[pergunta]) {
        const resposta = respostas[pergunta];
        console.log(`üìç [ANALYZER] Verificando pergunta ${pergunta}: "${resposta}"`);
        
        // Se cont√©m informa√ß√µes de localiza√ß√£o v√°lidas
        if (resposta && typeof resposta === 'string' && resposta.trim().length > 3) {
          console.log(`üìç [ANALYZER] Localiza√ß√£o encontrada na pergunta ${pergunta}: ${resposta}`);
          return resposta.trim();
        }
      }
    }
    
    // 2. Procurar por campos espec√≠ficos de localiza√ß√£o (nomes diretos)
    const camposLocalizacao = [
      'localizacao', 'localiza√ß√£o', 'cidade', 'endereco', 'endere√ßo',
      'local', 'regiao', 'regi√£o', 'estado', 'bairro', 'municipio', 'munic√≠pio'
    ];
    
    for (const campo of camposLocalizacao) {
      if (respostas[campo] && typeof respostas[campo] === 'string') {
        console.log('üìç [ANALYZER] Localiza√ß√£o encontrada no campo direto:', respostas[campo]);
        return respostas[campo];
      }
    }
    
    // 3. Procurar por palavras-chave relacionadas √† localiza√ß√£o
    const palavrasChaveLocalizacao = [
      'endere√ßo', 'endereco', 'rua', 'avenida', 'cidade', 'estado', 
      'bairro', 'localiza√ß√£o', 'localizacao', 'regi√£o', 'regiao'
    ];
    
    for (const [key, value] of Object.entries(respostas)) {
      if (typeof value === 'string') {
        const keyLower = key.toLowerCase();
        const valueLower = value.toLowerCase();
        
        // Verificar se a pergunta cont√©m palavras relacionadas √† localiza√ß√£o
        if (palavrasChaveLocalizacao.some(palavra => keyLower.includes(palavra) || valueLower.includes(palavra))) {
          // Verificar se a resposta parece ser uma localiza√ß√£o v√°lida
          if (value.length > 5 && (
            value.includes(',') || 
            value.includes('/') || 
            value.includes('-') ||
            /\b(rua|avenida|av|r\.|cidade|estado|sc|sp|rj|mg|pr|rs)\b/i.test(value)
          )) {
            console.log('üìç [ANALYZER] Localiza√ß√£o encontrada por palavra-chave na pergunta', key, ':', value);
            return value;
          }
        }
      }
    }
    
    // 4. Procurar por padr√µes de endere√ßo em todas as respostas
    for (const [key, value] of Object.entries(respostas)) {
      if (typeof value === 'string' && value.length > 10) {
        // Padr√µes que indicam endere√ßo
        const padraoEndereco = /\b(rua|avenida|av|r\.|estrada|rodovia|alameda|travessa|pra√ßa|largo)\b.*\d+/i;
        const padraoCidade = /\b\w+\s*\/\s*(sc|sp|rj|mg|pr|rs|ba|pe|ce|go|df|mt|ms|ro|ac|am|ap|pa|rr|to|al|se|pb|rn|pi|ma)\b/i;
        
        if (padraoEndereco.test(value) || padraoCidade.test(value)) {
          console.log('üìç [ANALYZER] Localiza√ß√£o encontrada por padr√£o de endere√ßo na pergunta', key, ':', value);
          return value;
        }
      }
    }
    
    console.warn('‚ö†Ô∏è [ANALYZER] Localiza√ß√£o n√£o encontrada, usando padr√£o');
    return 'Brasil'; // Padr√£o
  }

  /**
   * ‚ú® Extrair caracter√≠sticas especiais
   */
  extrairCaracteristicas(respostas) {
    const caracteristicas = [];
    const textoCompleto = JSON.stringify(respostas).toLowerCase();
    
    const caracteristicasEspeciais = [
      'piscina', 'churrasqueira', 'automa√ß√£o', 'home theater',
      'elevador', 'garagem', 'jardim', 'varanda', 'terra√ßo',
      'ar condicionado', 'aquecimento', 'lareira'
    ];
    
    caracteristicasEspeciais.forEach(caracteristica => {
      if (textoCompleto.includes(caracteristica)) {
        caracteristicas.push(caracteristica);
      }
    });
    
    console.log('‚ú® [ANALYZER] Caracter√≠sticas especiais:', caracteristicas);
    return caracteristicas;
  }

  /**
   * ‚è±Ô∏è Estimar prazo do projeto
   */
  estimarPrazo(respostas) {
    const complexidade = this.calcularComplexidade(respostas);
    const areaConstruida = this.extrairAreaConstruida(respostas);
    
    // F√≥rmula base: 30 dias + (√°rea/10) + fator complexidade
    let prazoBase = 30;
    prazoBase += Math.round(areaConstruida / 10);
    
    if (complexidade === 'alta') prazoBase += 30;
    else if (complexidade === 'media') prazoBase += 15;
    
    console.log('‚è±Ô∏è [ANALYZER] Prazo estimado:', prazoBase, 'dias');
    return prazoBase;
  }

  /**
   * üéØ Calcular confian√ßa da an√°lise
   */
  calcularConfianca(respostas) {
    const totalRespostas = Object.keys(respostas).length;
    let pontuacaoConfianca = 0;
    
    // Baseado no n√∫mero de respostas
    if (totalRespostas >= 20) pontuacaoConfianca += 40;
    else if (totalRespostas >= 10) pontuacaoConfianca += 30;
    else if (totalRespostas >= 5) pontuacaoConfianca += 20;
    else pontuacaoConfianca += 10;
    
    // Baseado na presen√ßa de campos importantes
    const camposImportantes = ['area_construida', 'tipologia', 'padrao', 'localizacao'];
    camposImportantes.forEach(campo => {
      if (respostas[campo]) pontuacaoConfianca += 15;
    });
    
    const confianca = Math.min(100, pontuacaoConfianca);
    console.log('üéØ [ANALYZER] Confian√ßa da an√°lise:', confianca + '%');
    
    return confianca;
  }
}

module.exports = BriefingAnalyzer;