/**
 * üß† ANALISADOR DIN√ÇMICO DE BRIEFINGS V3.0
 * 
 * Sistema completamente din√¢mico que funciona com qualquer estrutura
 * de briefing, usando mapeamento sem√¢ntico em vez de posi√ß√µes fixas
 */

const BriefingSemanticMapper = require('./briefingSemanticMapper');

class BriefingAnalyzerDynamic {
  constructor() {
    this.semanticMapper = new BriefingSemanticMapper();
    
    // Padr√µes para an√°lise sem√¢ntica (mantidos para fallbacks)
    this.tipologiaPatterns = {
      'RESIDENCIAL': [
        'residencial', 'casa', 'apartamento', 'resid√™ncia', 'moradia',
        'unifamiliar', 'multifamiliar', 'condom√≠nio', 'sobrado',
        'piscina', 'churrasqueira', 'home theater', 'su√≠te'
      ],
      'COMERCIAL': [
        'comercial', 'loja', 'escrit√≥rio', 'consult√≥rio', 'cl√≠nica',
        'restaurante', 'bar', 'hotel', 'pousada', 'sal√£o',
        'coworking', 'franquia', 'varejo', 'atendimento'
      ],
      'INDUSTRIAL': [
        'industrial', 'galp√£o', 'f√°brica', 'ind√∫stria', 'armaz√©m',
        'dep√≥sito', 'log√≠stica', 'produ√ß√£o', 'manufatura'
      ],
      'INSTITUCIONAL': [
        'escola', 'hospital', 'igreja', 'creche', 'universidade',
        'biblioteca', 'museu', 'teatro', 'audit√≥rio', 'p√∫blico'
      ]
    };

    this.padraoPatterns = {
      'ALTO': [
        'alto padr√£o', 'luxo', 'premium', 'sofisticado', 'requintado',
        'exclusivo', 'diferenciado', 'high-end', 'automa√ß√£o',
        'dom√≥tica', 'm√°rmore', 'granito', 'madeira nobre'
      ],
      'MEDIO': [
        'm√©dio padr√£o', 'padr√£o', 'intermedi√°rio', 'bom acabamento',
        'qualidade', 'confort√°vel', 'funcional'
      ],
      'SIMPLES': [
        'simples', 'b√°sico', 'econ√¥mico', 'popular', 'essencial',
        'm√≠nimo', 'funcional', 'sem luxo'
      ]
    };

    this.disciplinaPatterns = {
      'ARQUITETURA': ['arquitet√¥nico', 'arquitetura', 'projeto arquitet√¥nico', 'layout', 'planta'],
      'ESTRUTURAL': ['estrutural', 'estrutura', 'funda√ß√£o', 'laje', 'viga', 'pilar'],
      'INSTALACOES_HIDRAULICAS': ['hidr√°ulica', '√°gua', 'esgoto', 'tubula√ß√£o', 'encanamento'],
      'INSTALACOES_ELETRICAS': ['el√©trica', 'energia', 'ilumina√ß√£o', 'tomadas', 'quadro el√©trico'],
      'CLIMATIZACAO': ['ar condicionado', 'climatiza√ß√£o', 'ventila√ß√£o', 'exaust√£o'],
      'PAISAGISMO': ['paisagismo', 'jardim', '√°rea verde', 'plantas', 'vegeta√ß√£o'],
      'INTERIORES': ['interiores', 'decora√ß√£o', 'mobili√°rio', 'design de interiores'],
      'APROVACAO_LEGAL': ['aprova√ß√£o', 'prefeitura', 'bombeiros', 'legal', 'licen√ßa'],
      'MODELAGEM_3D': ['3d', 'maquete', 'renderiza√ß√£o', 'visualiza√ß√£o']
    };
  }

  /**
   * üéØ M√©todo principal para extrair dados estruturados dinamicamente
   */
  async extrairDadosEstruturados(briefing) {
    console.log('üß† [ANALYZER-DYNAMIC] Iniciando an√°lise din√¢mica do briefing:', briefing.id);
    
    try {
      // 1. Extrair respostas do briefing
      const respostas = this.extrairRespostas(briefing);
      console.log('üìã [ANALYZER-DYNAMIC] Total de respostas encontradas:', Object.keys(respostas).length);
      
      // 2. Usar mapeamento sem√¢ntico para identificar campos
      const mapeamentoSemantico = this.semanticMapper.mapearCampos(respostas);
      console.log('üéØ [ANALYZER-DYNAMIC] Campos mapeados semanticamente:', mapeamentoSemantico.totalCamposEncontrados);
      
      // 3. Analisar dados b√°sicos do briefing
      const dadosBasicos = this.analisarDadosBasicos(briefing);
      
      // 4. Combinar dados mapeados com an√°lise sem√¢ntica
      const dadosExtraidos = {
        // Dados b√°sicos do briefing
        ...dadosBasicos,
        
        // Dados extra√≠dos dinamicamente
        areaAtuacao: this.extrairAreaAtuacaoDinamica(mapeamentoSemantico, respostas, briefing),
        tipologia: this.identificarTipologiaDinamica(mapeamentoSemantico, respostas, briefing),
        areaConstruida: this.extrairAreaConstruidaDinamica(mapeamentoSemantico, respostas),
        areaTerreno: this.extrairAreaTerrenoDinamica(mapeamentoSemantico, respostas),
        localizacao: this.extrairLocalizacaoDinamica(mapeamentoSemantico, respostas),
        padrao: this.identificarPadraoDinamico(mapeamentoSemantico, respostas),
        complexidade: this.calcularComplexidadeDinamica(mapeamentoSemantico, respostas),
        disciplinasNecessarias: this.identificarDisciplinasDinamicas(mapeamentoSemantico, respostas, briefing),
        caracteristicasEspeciais: mapeamentoSemantico.campos.caracteristicas_especiais || [],
        prazoEstimado: this.estimarPrazoDinamico(mapeamentoSemantico, respostas),
        orcamentoOriginal: this.extrairOrcamentoDinamico(mapeamentoSemantico, respostas),
        
        // Metadados da an√°lise din√¢mica
        confiancaMapeamento: mapeamentoSemantico.confianca,
        totalCamposMapeados: mapeamentoSemantico.totalCamposEncontrados,
        confianca: this.calcularConfiancaDinamica(mapeamentoSemantico, respostas),
        fonteDados: 'briefing_dinamico_v3',
        timestampAnalise: new Date().toISOString(),
        versaoAnalyzer: '3.0.0-dynamic'
      };
      
      console.log('‚úÖ [ANALYZER-DYNAMIC] Dados extra√≠dos dinamicamente:', {
        tipologia: dadosExtraidos.tipologia,
        areaConstruida: dadosExtraidos.areaConstruida,
        areaTerreno: dadosExtraidos.areaTerreno,
        localizacao: dadosExtraidos.localizacao,
        padrao: dadosExtraidos.padrao,
        disciplinas: dadosExtraidos.disciplinasNecessarias.length,
        confianca: dadosExtraidos.confianca
      });
      
      return dadosExtraidos;
      
    } catch (error) {
      console.error('‚ùå [ANALYZER-DYNAMIC] Erro na an√°lise din√¢mica:', error);
      throw new Error(`Erro na an√°lise din√¢mica do briefing: ${error.message}`);
    }
  }

  /**
   * üìã Extrair respostas do briefing (mantido igual)
   */
  extrairRespostas(briefing) {
    let respostas = {};
    
    // Tentar extrair das observa√ß√µes
    if (briefing.observacoes) {
      try {
        const observacoes = JSON.parse(briefing.observacoes);
        if (observacoes.respostas) {
          respostas = { ...respostas, ...observacoes.respostas };
        }
        if (observacoes.estruturaPersonalizada?.respostas) {
          respostas = { ...respostas, ...observacoes.estruturaPersonalizada.respostas };
        }
      } catch (error) {
        console.warn('‚ö†Ô∏è [ANALYZER-DYNAMIC] Erro ao parsear observa√ß√µes:', error.message);
      }
    }
    
    // Tentar extrair dos dados_extraidos
    if (briefing.dados_extraidos) {
      try {
        const dadosExtraidos = JSON.parse(briefing.dados_extraidos);
        if (dadosExtraidos.respostas) {
          respostas = { ...respostas, ...dadosExtraidos.respostas };
        }
      } catch (error) {
        console.warn('‚ö†Ô∏è [ANALYZER-DYNAMIC] Erro ao parsear dados_extraidos:', error.message);
      }
    }
    
    // Tentar extrair da metadata
    if (briefing.metadata) {
      try {
        const metadata = JSON.parse(briefing.metadata);
        if (metadata.respostas) {
          respostas = { ...respostas, ...metadata.respostas };
        }
      } catch (error) {
        console.warn('‚ö†Ô∏è [ANALYZER-DYNAMIC] Erro ao parsear metadata:', error.message);
      }
    }
    
    return respostas;
  }

  /**
   * üìä Analisar dados b√°sicos do briefing (mantido igual)
   */
  analisarDadosBasicos(briefing) {
    return {
      briefingId: briefing.id,
      nomeProjeto: briefing.nome_projeto,
      clienteId: briefing.cliente_id,
      clienteNome: briefing.cliente_nome,
      responsavelId: briefing.responsavel_id,
      responsavelNome: briefing.responsavel_nome,
      escritorioId: briefing.escritorio_id,
      disciplinaPrincipal: briefing.disciplina,
      tipologiaOriginal: briefing.tipologia,
      areaOriginal: briefing.area,
      descricao: briefing.descricao,
      objetivos: briefing.objetivos,
      prazoOriginal: briefing.prazo,
      orcamentoOriginal: briefing.orcamento
    };
  }

  /**
   * üè¢ Extrair √°rea de atua√ß√£o dinamicamente
   */
  extrairAreaAtuacaoDinamica(mapeamentoSemantico, respostas, briefing) {
    console.log('üè¢ [ANALYZER-DYNAMIC] Extraindo √°rea de atua√ß√£o dinamicamente...');
    
    // 1. Usar mapeamento sem√¢ntico primeiro
    if (mapeamentoSemantico.campos.area_atuacao) {
      console.log('üè¢ [ANALYZER-DYNAMIC] √Årea de atua√ß√£o encontrada via mapeamento sem√¢ntico:', mapeamentoSemantico.campos.area_atuacao);
      return mapeamentoSemantico.campos.area_atuacao.toUpperCase();
    }

    // 2. Verificar campo 'area' do briefing
    if (briefing.area && typeof briefing.area === 'string') {
      const areaLower = briefing.area.toLowerCase();
      const tiposAtuacao = ['residencial', 'comercial', 'industrial', 'institucional', 'mista'];
      
      for (const tipo of tiposAtuacao) {
        if (areaLower.includes(tipo)) {
          console.log('üè¢ [ANALYZER-DYNAMIC] √Årea de atua√ß√£o encontrada no campo area do briefing:', tipo.toUpperCase());
          return tipo.toUpperCase();
        }
      }
    }

    // 3. An√°lise sem√¢ntica em todas as respostas
    const textoCompleto = JSON.stringify(respostas).toLowerCase();
    const tiposAtuacao = ['residencial', 'comercial', 'industrial', 'institucional', 'mista'];
    
    for (const tipo of tiposAtuacao) {
      if (textoCompleto.includes(tipo)) {
        console.log('üè¢ [ANALYZER-DYNAMIC] √Årea de atua√ß√£o encontrada por an√°lise sem√¢ntica:', tipo.toUpperCase());
        return tipo.toUpperCase();
      }
    }

    // 4. Fallback: inferir da tipologia
    if (briefing.tipologia) {
      const tipologiaLower = briefing.tipologia.toLowerCase();
      if (tipologiaLower.includes('unifamiliar') || tipologiaLower.includes('casa') || tipologiaLower.includes('apartamento')) {
        console.log('üè¢ [ANALYZER-DYNAMIC] √Årea de atua√ß√£o inferida da tipologia: RESIDENCIAL');
        return 'RESIDENCIAL';
      }
    }

    return 'RESIDENCIAL'; // Padr√£o mais comum
  }

  /**
   * üè† Identificar tipologia dinamicamente
   */
  identificarTipologiaDinamica(mapeamentoSemantico, respostas, briefing) {
    console.log('üè† [ANALYZER-DYNAMIC] Identificando tipologia dinamicamente...');

    // 1. Usar mapeamento sem√¢ntico primeiro
    if (mapeamentoSemantico.campos.tipologia) {
      console.log('üè† [ANALYZER-DYNAMIC] Tipologia encontrada via mapeamento sem√¢ntico:', mapeamentoSemantico.campos.tipologia);
      return mapeamentoSemantico.campos.tipologia.toUpperCase();
    }

    // 2. Verificar tipologia j√° definida no briefing
    if (briefing.tipologia && briefing.tipologia !== 'null') {
      console.log('üè† [ANALYZER-DYNAMIC] Tipologia do briefing:', briefing.tipologia);
      return briefing.tipologia.toUpperCase();
    }
    
    // 3. An√°lise por padr√µes sem√¢nticos
    const textoCompleto = JSON.stringify(respostas).toLowerCase();
    let pontuacoes = {};
    
    Object.entries(this.tipologiaPatterns).forEach(([tipo, patterns]) => {
      pontuacoes[tipo] = 0;
      patterns.forEach(pattern => {
        const matches = (textoCompleto.match(new RegExp(pattern, 'gi')) || []).length;
        pontuacoes[tipo] += matches;
      });
    });
    
    const tipologiaIdentificada = Object.entries(pontuacoes)
      .sort(([,a], [,b]) => b - a)[0][0];
    
    console.log('üè† [ANALYZER-DYNAMIC] Pontua√ß√µes de tipologia:', pontuacoes);
    console.log('üè† [ANALYZER-DYNAMIC] Tipologia identificada:', tipologiaIdentificada);
    
    return tipologiaIdentificada;
  }

  /**
   * üìê Extrair √°rea constru√≠da dinamicamente
   */
  extrairAreaConstruidaDinamica(mapeamentoSemantico, respostas) {
    console.log('üìê [ANALYZER-DYNAMIC] Extraindo √°rea constru√≠da dinamicamente...');
    
    // 1. Usar mapeamento sem√¢ntico primeiro
    if (mapeamentoSemantico.campos.area_construida) {
      console.log('üìê [ANALYZER-DYNAMIC] √Årea constru√≠da encontrada via mapeamento sem√¢ntico:', mapeamentoSemantico.campos.area_construida, 'm¬≤');
      return mapeamentoSemantico.campos.area_construida;
    }

    console.warn('‚ö†Ô∏è [ANALYZER-DYNAMIC] √Årea constru√≠da n√£o encontrada, usando padr√£o: 150m¬≤');
    return 150; // Valor padr√£o
  }

  /**
   * üèûÔ∏è Extrair √°rea do terreno dinamicamente
   */
  extrairAreaTerrenoDinamica(mapeamentoSemantico, respostas) {
    console.log('üèûÔ∏è [ANALYZER-DYNAMIC] Extraindo √°rea do terreno dinamicamente...');
    
    // 1. Usar mapeamento sem√¢ntico primeiro
    if (mapeamentoSemantico.campos.area_terreno) {
      console.log('üèûÔ∏è [ANALYZER-DYNAMIC] √Årea do terreno encontrada via mapeamento sem√¢ntico:', mapeamentoSemantico.campos.area_terreno, 'm¬≤');
      return mapeamentoSemantico.campos.area_terreno;
    }

    console.warn('‚ö†Ô∏è [ANALYZER-DYNAMIC] √Årea do terreno n√£o encontrada');
    return null;
  }

  /**
   * üìç Extrair localiza√ß√£o dinamicamente
   */
  extrairLocalizacaoDinamica(mapeamentoSemantico, respostas) {
    console.log('üìç [ANALYZER-DYNAMIC] Extraindo localiza√ß√£o dinamicamente...');
    
    // 1. Usar mapeamento sem√¢ntico primeiro
    if (mapeamentoSemantico.campos.localizacao) {
      console.log('üìç [ANALYZER-DYNAMIC] Localiza√ß√£o encontrada via mapeamento sem√¢ntico:', mapeamentoSemantico.campos.localizacao);
      return mapeamentoSemantico.campos.localizacao;
    }

    console.warn('‚ö†Ô∏è [ANALYZER-DYNAMIC] Localiza√ß√£o n√£o encontrada, usando padr√£o');
    return 'Brasil'; // Padr√£o
  }

  /**
   * ‚≠ê Identificar padr√£o dinamicamente
   */
  identificarPadraoDinamico(mapeamentoSemantico, respostas) {
    console.log('‚≠ê [ANALYZER-DYNAMIC] Identificando padr√£o dinamicamente...');

    // 1. Usar mapeamento sem√¢ntico primeiro
    if (mapeamentoSemantico.campos.padrao) {
      console.log('‚≠ê [ANALYZER-DYNAMIC] Padr√£o encontrado via mapeamento sem√¢ntico:', mapeamentoSemantico.campos.padrao);
      return mapeamentoSemantico.campos.padrao.toLowerCase();
    }

    // 2. An√°lise por padr√µes sem√¢nticos
    const textoCompleto = JSON.stringify(respostas).toLowerCase();
    let pontuacoes = {};
    
    Object.entries(this.padraoPatterns).forEach(([padrao, patterns]) => {
      pontuacoes[padrao] = 0;
      patterns.forEach(pattern => {
        const matches = (textoCompleto.match(new RegExp(pattern, 'gi')) || []).length;
        pontuacoes[padrao] += matches;
      });
    });
    
    const padraoIdentificado = Object.entries(pontuacoes)
      .sort(([,a], [,b]) => b - a)[0][0];
    
    console.log('‚≠ê [ANALYZER-DYNAMIC] Pontua√ß√µes de padr√£o:', pontuacoes);
    console.log('‚≠ê [ANALYZER-DYNAMIC] Padr√£o identificado:', padraoIdentificado);
    
    return padraoIdentificado.toLowerCase();
  }

  /**
   * üéØ Calcular complexidade dinamicamente
   */
  calcularComplexidadeDinamica(mapeamentoSemantico, respostas) {
    const padrao = this.identificarPadraoDinamico(mapeamentoSemantico, respostas);
    const totalRespostas = Object.keys(respostas).length;
    const caracteristicasEspeciais = mapeamentoSemantico.campos.caracteristicas_especiais || [];
    
    // Fatores de complexidade
    let pontuacaoComplexidade = 0;
    
    // Baseado no padr√£o
    if (padrao === 'alto') pontuacaoComplexidade += 3;
    else if (padrao === 'medio') pontuacaoComplexidade += 2;
    else pontuacaoComplexidade += 1;
    
    // Baseado no n√∫mero de respostas
    if (totalRespostas > 20) pontuacaoComplexidade += 2;
    else if (totalRespostas > 10) pontuacaoComplexidade += 1;
    
    // Baseado em caracter√≠sticas especiais
    pontuacaoComplexidade += caracteristicasEspeciais.length;
    
    // Determinar complexidade final
    let complexidade;
    if (pontuacaoComplexidade >= 6) complexidade = 'alta';
    else if (pontuacaoComplexidade >= 3) complexidade = 'media';
    else complexidade = 'simples';
    
    console.log('üéØ [ANALYZER-DYNAMIC] Pontua√ß√£o de complexidade:', pontuacaoComplexidade);
    console.log('üéØ [ANALYZER-DYNAMIC] Complexidade calculada:', complexidade);
    
    return complexidade;
  }

  /**
   * üîß Identificar disciplinas dinamicamente
   */
  identificarDisciplinasDinamicas(mapeamentoSemantico, respostas, briefing) {
    const disciplinasIdentificadas = new Set();
    
    // Sempre incluir a disciplina principal do briefing
    if (briefing.disciplina) {
      disciplinasIdentificadas.add(briefing.disciplina.toLowerCase());
    }
    
    // Analisar respostas para identificar outras disciplinas
    const textoCompleto = JSON.stringify(respostas).toLowerCase();
    
    Object.entries(this.disciplinaPatterns).forEach(([disciplina, patterns]) => {
      patterns.forEach(pattern => {
        if (textoCompleto.includes(pattern)) {
          disciplinasIdentificadas.add(disciplina.toLowerCase());
        }
      });
    });
    
    // Disciplinas b√°sicas sempre necess√°rias
    const disciplinasBasicas = ['arquitetura', 'estrutural', 'instalacoes_hidraulicas', 'instalacoes_eletricas'];
    disciplinasBasicas.forEach(disc => disciplinasIdentificadas.add(disc));
    
    // Adicionar disciplinas baseadas em caracter√≠sticas especiais
    const caracteristicas = mapeamentoSemantico.campos.caracteristicas_especiais || [];
    if (caracteristicas.includes('paisagismo') || caracteristicas.includes('jardim')) {
      disciplinasIdentificadas.add('paisagismo');
    }
    if (caracteristicas.includes('home_theater') || caracteristicas.includes('automacao')) {
      disciplinasIdentificadas.add('interiores');
    }
    
    const resultado = Array.from(disciplinasIdentificadas);
    console.log('üîß [ANALYZER-DYNAMIC] Disciplinas identificadas dinamicamente:', resultado);
    
    return resultado;
  }

  /**
   * ‚è±Ô∏è Estimar prazo dinamicamente
   */
  estimarPrazoDinamico(mapeamentoSemantico, respostas) {
    // 1. Usar mapeamento sem√¢ntico primeiro
    if (mapeamentoSemantico.campos.prazo) {
      console.log('‚è±Ô∏è [ANALYZER-DYNAMIC] Prazo encontrado via mapeamento sem√¢ntico:', mapeamentoSemantico.campos.prazo, 'dias');
      return mapeamentoSemantico.campos.prazo;
    }

    // 2. Calcular baseado em outros fatores
    const complexidade = this.calcularComplexidadeDinamica(mapeamentoSemantico, respostas);
    const areaConstruida = this.extrairAreaConstruidaDinamica(mapeamentoSemantico, respostas);
    
    // F√≥rmula base: 30 dias + (√°rea/10) + fator complexidade
    let prazoBase = 30;
    prazoBase += Math.round(areaConstruida / 10);
    
    if (complexidade === 'alta') prazoBase += 30;
    else if (complexidade === 'media') prazoBase += 15;
    
    console.log('‚è±Ô∏è [ANALYZER-DYNAMIC] Prazo estimado dinamicamente:', prazoBase, 'dias');
    return prazoBase;
  }

  /**
   * üí∞ Extrair or√ßamento dinamicamente
   */
  extrairOrcamentoDinamico(mapeamentoSemantico, respostas) {
    // 1. Usar mapeamento sem√¢ntico primeiro
    if (mapeamentoSemantico.campos.orcamento) {
      console.log('üí∞ [ANALYZER-DYNAMIC] Or√ßamento encontrado via mapeamento sem√¢ntico:', mapeamentoSemantico.campos.orcamento);
      return mapeamentoSemantico.campos.orcamento;
    }

    return null;
  }

  /**
   * üéØ Calcular confian√ßa din√¢mica
   */
  calcularConfiancaDinamica(mapeamentoSemantico, respostas) {
    const totalRespostas = Object.keys(respostas).length;
    const camposMapeados = mapeamentoSemantico.totalCamposEncontrados;
    const camposDisponiveis = mapeamentoSemantico.totalCamposDisponiveis;
    
    let pontuacaoConfianca = 0;
    
    // Baseado no n√∫mero de respostas
    if (totalRespostas >= 20) pontuacaoConfianca += 30;
    else if (totalRespostas >= 10) pontuacaoConfianca += 20;
    else if (totalRespostas >= 5) pontuacaoConfianca += 10;
    
    // Baseado na taxa de mapeamento sem√¢ntico
    const taxaMapeamento = (camposMapeados / camposDisponiveis) * 100;
    pontuacaoConfianca += Math.round(taxaMapeamento * 0.5); // At√© 50 pontos
    
    // Baseado na confian√ßa individual dos campos
    const confiancasIndividuais = Object.values(mapeamentoSemantico.confianca || {});
    if (confiancasIndividuais.length > 0) {
      const mediaConfiancas = confiancasIndividuais.reduce((a, b) => a + b, 0) / confiancasIndividuais.length;
      pontuacaoConfianca += Math.round(mediaConfiancas * 0.2); // At√© 20 pontos
    }
    
    const confianca = Math.min(100, pontuacaoConfianca);
    console.log('üéØ [ANALYZER-DYNAMIC] Confian√ßa din√¢mica calculada:', confianca + '%');
    
    return confianca;
  }
}

module.exports = BriefingAnalyzerDynamic;