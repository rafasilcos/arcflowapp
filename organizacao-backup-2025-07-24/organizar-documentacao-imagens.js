#!/usr/bin/env node

/**
 * üóÇÔ∏è SCRIPT DE ORGANIZA√á√ÉO AUTOM√ÅTICA
 * 
 * Organiza todos os arquivos espalhados (imagens, documentos, scripts)
 * seguindo uma estrutura profissional e l√≥gica.
 */

const fs = require('fs');
const path = require('path');

const BACKUP_DIR = `organizacao-backup-${new Date().toISOString().split('T')[0]}`;

class FileOrganizer {
  constructor() {
    this.movedFiles = [];
    this.errors = [];
    this.createdDirs = [];
    
    // Mapeamento de arquivos para destinos
    this.fileMapping = {
      // IMAGENS - Briefings
      briefings_images: {
        pattern: /^briefing-.*\.png$/,
        destination: 'assets/images/briefings/',
        description: 'Screenshots de briefings'
      },
      
      // IMAGENS - Debug
      debug_images: {
        pattern: /^debug-.*\.png$/,
        destination: 'assets/images/debug/',
        description: 'Screenshots de debug'
      },
      
      // IMAGENS - Erros
      error_images: {
        pattern: /^erro-.*\.png$/,
        destination: 'assets/images/errors/',
        description: 'Screenshots de erros'
      },
      
      // IMAGENS - Navega√ß√£o
      navigation_images: {
        pattern: /^(navegacao|selecao|perguntas)-.*\.png$/,
        destination: 'assets/images/navigation/',
        description: 'Screenshots de navega√ß√£o'
      },
      
      // DOCUMENTOS - An√°lises
      analysis_docs: {
        pattern: /^ANALISE_.*\.md$/,
        destination: 'docs/analysis/readme/',
        description: 'An√°lises t√©cnicas'
      },
      
      // DOCUMENTOS - Corre√ß√µes e Relat√≥rios
      reports_docs: {
        pattern: /^(CORRECAO|RESUMO|RELATORIO)_.*\.md$/,
        destination: 'docs/reports/readme/',
        description: 'Corre√ß√µes e relat√≥rios'
      },
      
      // DOCUMENTOS - Manuais
      manuals_docs: {
        pattern: /^(MANUAL|NOVA|MAPEAMENTO)_.*\.md$/,
        destination: 'docs/manuals/readme/',
        description: 'Manuais e documenta√ß√£o'
      },
      
      // SCRIPTS - Briefings
      briefing_scripts: {
        pattern: /^(sistema-briefing|executar-briefings|sistema-preenchimento).*\.js$/,
        destination: 'scripts/briefings/',
        description: 'Scripts de briefings'
      },
      
      // SCRIPTS - Debug e Teste
      debug_scripts: {
        pattern: /^(debug|teste)-.*\.js$/,
        destination: 'scripts/debug/',
        description: 'Scripts de debug e teste'
      },
      
      // SCRIPTS - Sistema
      system_scripts: {
        pattern: /^(sistema|configurar|analise)-.*\.js$/,
        destination: 'scripts/utils/',
        description: 'Scripts do sistema'
      },
      
      // CONFIGURA√á√ïES - JSON
      config_json: {
        pattern: /^.*-config\.json$|^arquivos-para-deletar.*\.json$|^relatorio-.*\.json$/,
        destination: 'assets/configs/',
        description: 'Arquivos de configura√ß√£o JSON'
      },
      
      // CONFIGURA√á√ïES - HTML
      config_html: {
        pattern: /^interface-.*\.html$/,
        destination: 'assets/configs/',
        description: 'Interfaces de configura√ß√£o'
      },
      
      // SCRIPTS - Deploy
      deploy_scripts: {
        pattern: /\.(bat|ps1)$/,
        destination: 'scripts/deployment/',
        description: 'Scripts de deploy'
      },
      
      // ARQUIVOS ESPECIAIS
      special_files: {
        pattern: /^(start-|test-|testar-).*\.(js|md)$/,
        destination: 'scripts/utils/',
        description: 'Arquivos especiais'
      }
    };
  }

  // Criar backup completo
  async createBackup() {
    console.log('üíæ Criando backup antes da organiza√ß√£o...');
    
    try {
      if (!fs.existsSync(BACKUP_DIR)) {
        fs.mkdirSync(BACKUP_DIR, { recursive: true });
      }
      
      // Copiar apenas arquivos da raiz (n√£o pastas)
      const rootFiles = fs.readdirSync('.').filter(item => {
        const stats = fs.statSync(item);
        return stats.isFile();
      });
      
      let copiedCount = 0;
      for (const file of rootFiles) {
        fs.copyFileSync(file, path.join(BACKUP_DIR, file));
        copiedCount++;
      }
      
      console.log(`‚úÖ Backup criado: ${copiedCount} arquivos em ${BACKUP_DIR}`);
      return true;
      
    } catch (error) {
      console.error('‚ùå Erro ao criar backup:', error.message);
      return false;
    }
  }

  // Criar estrutura de diret√≥rios
  createDirectoryStructure() {
    console.log('üìÅ Criando estrutura de diret√≥rios...');
    
    const directories = [
      'docs/api/readme',
      'docs/auth/readme/screenshots',
      'docs/briefings/readme/screenshots',
      'docs/orcamentos/readme/screenshots',
      'docs/clientes/readme',
      'docs/deployment/readme/scripts',
      'docs/analysis/readme/data',
      'docs/reports/readme',
      'docs/manuals/readme',
      'assets/images/briefings',
      'assets/images/debug',
      'assets/images/errors',
      'assets/images/navigation',
      'assets/images/ui',
      'assets/configs',
      'scripts/briefings',
      'scripts/debug',
      'scripts/deployment',
      'scripts/utils',
      'temp/logs',
      'temp/backups',
      'temp/reports'
    ];
    
    for (const dir of directories) {
      if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true });
        this.createdDirs.push(dir);
        console.log(`   üìÇ ${dir}`);
      }
    }
    
    console.log(`‚úÖ ${this.createdDirs.length} diret√≥rios criados`);
  }

  // Categorizar arquivo
  categorizeFile(fileName) {
    for (const [category, config] of Object.entries(this.fileMapping)) {
      if (config.pattern.test(fileName)) {
        return {
          category,
          destination: config.destination,
          description: config.description
        };
      }
    }
    return null;
  }

  // Detectar depend√™ncias em arquivo JS
  detectDependencies(filePath) {
    try {
      const content = fs.readFileSync(filePath, 'utf8');
      const dependencies = [];
      
      // Procurar por require() relativos
      const requireMatches = content.match(/require\(['"`]\.\/[^'"`]+['"`]\)/g);
      if (requireMatches) {
        requireMatches.forEach(match => {
          const dep = match.match(/['"`]([^'"`]+)['"`]/)[1];
          dependencies.push(dep);
        });
      }
      
      // Procurar por import relativos
      const importMatches = content.match(/import.*from\s+['"`]\.\/[^'"`]+['"`]/g);
      if (importMatches) {
        importMatches.forEach(match => {
          const dep = match.match(/['"`]([^'"`]+)['"`]/)[1];
          dependencies.push(dep);
        });
      }
      
      return dependencies;
    } catch (error) {
      return [];
    }
  }

  // Ajustar caminhos em arquivo
  fixPathsInFile(filePath, oldPaths, newPaths) {
    try {
      let content = fs.readFileSync(filePath, 'utf8');
      let modified = false;
      
      for (let i = 0; i < oldPaths.length; i++) {
        const oldPath = oldPaths[i];
        const newPath = newPaths[i];
        
        // Ajustar require()
        const requireRegex = new RegExp(`require\\(['"\`]${oldPath.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}['"\`]\\)`, 'g');
        if (requireRegex.test(content)) {
          content = content.replace(requireRegex, `require('${newPath}')`);
          modified = true;
          console.log(`     üîß Ajustado: ${oldPath} ‚Üí ${newPath}`);
        }
        
        // Ajustar import
        const importRegex = new RegExp(`from\\s+['"\`]${oldPath.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}['"\`]`, 'g');
        if (importRegex.test(content)) {
          content = content.replace(importRegex, `from '${newPath}'`);
          modified = true;
          console.log(`     üîß Ajustado: ${oldPath} ‚Üí ${newPath}`);
        }
      }
      
      if (modified) {
        fs.writeFileSync(filePath, content);
        return true;
      }
      
      return false;
    } catch (error) {
      console.error(`     ‚ùå Erro ao ajustar caminhos: ${error.message}`);
      return false;
    }
  }

  // Mover arquivo com corre√ß√£o de depend√™ncias
  moveFile(fileName, destination) {
    try {
      const sourcePath = fileName;
      const destPath = path.join(destination, fileName);
      
      // Verificar se arquivo existe
      if (!fs.existsSync(sourcePath)) {
        console.log(`   ‚ö†Ô∏è ${fileName} (n√£o encontrado)`);
        return false;
      }
      
      // Verificar se destino existe
      if (!fs.existsSync(destination)) {
        fs.mkdirSync(destination, { recursive: true });
      }
      
      // Se for arquivo JS, verificar depend√™ncias
      if (fileName.endsWith('.js')) {
        const dependencies = this.detectDependencies(sourcePath);
        if (dependencies.length > 0) {
          console.log(`     üîç Depend√™ncias encontradas: ${dependencies.join(', ')}`);
          
          // Calcular novos caminhos relativos
          const newPaths = dependencies.map(dep => {
            // Se a depend√™ncia ainda est√° na raiz, calcular caminho relativo
            const depFile = dep.replace('./', '');
            const levelsUp = destination.split('/').length;
            const relativePath = '../'.repeat(levelsUp) + depFile;
            return relativePath;
          });
          
          // Mover arquivo primeiro
          fs.renameSync(sourcePath, destPath);
          
          // Ajustar caminhos no arquivo movido
          this.fixPathsInFile(destPath, dependencies, newPaths);
        } else {
          // Mover arquivo sem depend√™ncias
          fs.renameSync(sourcePath, destPath);
        }
      } else {
        // Mover arquivo n√£o-JS
        fs.renameSync(sourcePath, destPath);
      }
      
      this.movedFiles.push({
        from: sourcePath,
        to: destPath,
        category: destination
      });
      
      console.log(`   ‚úÖ ${fileName} ‚Üí ${destination}`);
      return true;
      
    } catch (error) {
      console.error(`   ‚ùå ${fileName}: ${error.message}`);
      this.errors.push({
        file: fileName,
        error: error.message
      });
      return false;
    }
  }

  // Organizar arquivos
  organizeFiles() {
    console.log('üóÇÔ∏è Organizando arquivos...');
    
    // Obter todos os arquivos da raiz
    const rootFiles = fs.readdirSync('.').filter(item => {
      const stats = fs.statSync(item);
      return stats.isFile() && !item.startsWith('.') && item !== 'package.json' && item !== 'package-lock.json' && item !== 'tsconfig.json' && item !== 'next-env.d.ts';
    });
    
    console.log(`üìã ${rootFiles.length} arquivos para organizar`);
    
    // Agrupar por categoria
    const categorizedFiles = {};
    const uncategorizedFiles = [];
    
    for (const file of rootFiles) {
      const category = this.categorizeFile(file);
      if (category) {
        if (!categorizedFiles[category.category]) {
          categorizedFiles[category.category] = [];
        }
        categorizedFiles[category.category].push({
          file,
          destination: category.destination,
          description: category.description
        });
      } else {
        uncategorizedFiles.push(file);
      }
    }
    
    // Mover arquivos por categoria
    for (const [categoryName, files] of Object.entries(categorizedFiles)) {
      console.log(`\nüìÇ ${categoryName.toUpperCase()} (${files.length} arquivos)`);
      console.log(`   ${files[0].description}`);
      
      for (const fileInfo of files) {
        this.moveFile(fileInfo.file, fileInfo.destination);
      }
    }
    
    // Mostrar arquivos n√£o categorizados
    if (uncategorizedFiles.length > 0) {
      console.log(`\n‚ùì ARQUIVOS N√ÉO CATEGORIZADOS (${uncategorizedFiles.length}):`);
      uncategorizedFiles.forEach(file => {
        console.log(`   - ${file}`);
      });
    }
  }

  // Criar README principal
  createMainReadme() {
    const readmeContent = `# üöÄ ArcFlow - Sistema de Gest√£o para Arquitetura e Engenharia

## üìã Sobre o Projeto

ArcFlow √© uma plataforma SaaS especializada para escrit√≥rios de Arquitetura, Engenharia e Constru√ß√£o (AEC) no Brasil. O sistema revoluciona o gerenciamento de projetos e automa√ß√£o de workflows para empresas do setor.

## üèóÔ∏è Estrutura do Projeto

### üìÅ Diret√≥rios Principais

- **\`backend/\`** - API e servidor Node.js
- **\`frontend/\`** - Interface React/Next.js
- **\`docs/\`** - Documenta√ß√£o completa
- **\`assets/\`** - Recursos est√°ticos (imagens, configs)
- **\`scripts/\`** - Scripts utilit√°rios e automa√ß√£o

### üìö Documenta√ß√£o

- **[Documenta√ß√£o da API](docs/api/readme/)** - Endpoints e especifica√ß√µes
- **[Sistema de Briefings](docs/briefings/readme/)** - Documenta√ß√£o de briefings
- **[Sistema de Or√ßamentos](docs/orcamentos/readme/)** - Documenta√ß√£o de or√ßamentos
- **[An√°lises T√©cnicas](docs/analysis/readme/)** - Relat√≥rios e an√°lises
- **[Manuais](docs/manuals/readme/)** - Guias de usu√°rio

## üöÄ Como Executar

### Backend
\`\`\`bash
cd backend
npm install
npm start
\`\`\`

### Frontend
\`\`\`bash
cd frontend
npm install
npm run dev
\`\`\`

## üõ†Ô∏è Scripts √öteis

- **\`scripts/deployment/\`** - Scripts de deploy
- **\`scripts/briefings/\`** - Automa√ß√£o de briefings
- **\`scripts/utils/\`** - Utilit√°rios diversos

## üìä Funcionalidades Principais

- üß† **Briefings Inteligentes** - 230+ perguntas especializadas
- üí∞ **Or√ßamentos Autom√°ticos** - Gera√ß√£o baseada em IA
- üë• **Gest√£o de Clientes** - CRUD completo
- üìà **Dashboard Analytics** - M√©tricas em tempo real
- üîê **Autentica√ß√£o Segura** - JWT com refresh tokens

## üéØ Tecnologias

- **Backend**: Node.js, Express, PostgreSQL, Redis
- **Frontend**: React, Next.js, TypeScript, Tailwind CSS
- **Banco**: PostgreSQL com Prisma ORM
- **Cache**: Redis para performance
- **Deploy**: Docker, AWS/Vercel

## üìû Suporte

Para d√∫vidas e suporte, consulte a documenta√ß√£o em \`docs/\` ou entre em contato com a equipe de desenvolvimento.

---

**¬© 2024 ArcFlow - Sistema de Gest√£o para Escrit√≥rios de Arquitetura e Engenharia**
`;

    fs.writeFileSync('README.md', readmeContent);
    console.log('üìÑ README.md principal criado');
  }

  // Gerar relat√≥rio final
  generateReport() {
    console.log('\n' + '='.repeat(80));
    console.log('üìä RELAT√ìRIO FINAL DA ORGANIZA√á√ÉO');
    console.log('='.repeat(80));
    
    console.log(`‚úÖ Arquivos movidos: ${this.movedFiles.length}`);
    console.log(`üìÅ Diret√≥rios criados: ${this.createdDirs.length}`);
    console.log(`‚ùå Erros encontrados: ${this.errors.length}`);
    console.log(`üíæ Backup criado em: ${BACKUP_DIR}`);
    
    // Agrupar por categoria
    const byCategory = {};
    this.movedFiles.forEach(file => {
      const category = file.category;
      if (!byCategory[category]) {
        byCategory[category] = [];
      }
      byCategory[category].push(file);
    });
    
    console.log('\nüìã ARQUIVOS MOVIDOS POR CATEGORIA:');
    for (const [category, files] of Object.entries(byCategory)) {
      console.log(`   üìÇ ${category}: ${files.length} arquivos`);
    }
    
    if (this.errors.length > 0) {
      console.log('\n‚ùå ERROS ENCONTRADOS:');
      this.errors.forEach(error => {
        console.log(`   - ${error.file}: ${error.error}`);
      });
    }
    
    // Salvar relat√≥rio
    const report = {
      date: new Date().toISOString(),
      movedFiles: this.movedFiles,
      createdDirs: this.createdDirs,
      errors: this.errors,
      backupLocation: BACKUP_DIR,
      summary: {
        totalMoved: this.movedFiles.length,
        totalDirs: this.createdDirs.length,
        totalErrors: this.errors.length
      }
    };
    
    const reportFile = `relatorio-organizacao-${new Date().toISOString().split('T')[0]}.json`;
    fs.writeFileSync(reportFile, JSON.stringify(report, null, 2));
    console.log(`üìÑ Relat√≥rio salvo em: ${reportFile}`);
    
    console.log('\nüéØ RESULTADO:');
    console.log('‚úÖ Projeto organizado profissionalmente');
    console.log('‚úÖ Documenta√ß√£o estruturada');
    console.log('‚úÖ Imagens categorizadas');
    console.log('‚úÖ Scripts organizados');
    console.log('‚úÖ Raiz limpa e profissional');
    
    console.log('\nüìÅ ESTRUTURA FINAL:');
    console.log('   üìÇ docs/ - Documenta√ß√£o completa');
    console.log('   üìÇ assets/ - Imagens e configura√ß√µes');
    console.log('   üìÇ scripts/ - Scripts organizados');
    console.log('   üìÇ temp/ - Arquivos tempor√°rios');
    console.log('   üìÑ README.md - Documenta√ß√£o principal');
  }

  // Executar organiza√ß√£o completa
  async execute() {
    console.log('üöÄ Iniciando organiza√ß√£o completa do projeto...');
    
    // 1. Criar backup
    const backupOk = await this.createBackup();
    if (!backupOk) {
      console.error('‚ùå Falha no backup. Abortando organiza√ß√£o.');
      return;
    }
    
    // 2. Criar estrutura de diret√≥rios
    this.createDirectoryStructure();
    
    // 3. Organizar arquivos
    this.organizeFiles();
    
    // 4. Criar README principal
    this.createMainReadme();
    
    // 5. Gerar relat√≥rio
    this.generateReport();
    
    console.log('\nüéâ ORGANIZA√á√ÉO CONCLU√çDA COM SUCESSO!');
    console.log('üèóÔ∏è Projeto agora tem estrutura profissional e escal√°vel');
  }
}

// Executar organiza√ß√£o
async function main() {
  const organizer = new FileOrganizer();
  await organizer.execute();
}

if (require.main === module) {
  main().catch(console.error);
}

module.exports = { FileOrganizer };